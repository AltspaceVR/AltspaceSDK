<!DOCTYPE html>
<html lang=en>
<head>
<meta charset=utf-8>
<title>Hats Example</title>
<script src="http://sdk.altvr.com/libs/three.js/r73/build/three.js"></script>
<script src="../dist/altspace.min.js"></script>
<script src="http://sdk.altvr.com/libs/three.js/r73/examples/js/loaders/OBJMTLLoader.js"></script>
<script src="http://sdk.altvr.com/libs/three.js/r73/examples/js/loaders/MTLLoader.js"></script>
</head>
<body>
</body>
<script>

HatsApp = (function(){

	var CONFIG = {
		models: [
			{name: 'wizardhat',  position: {x: -150, y: 0, z: 0}, offset: {x: 0, y: 10, z: 80}},
			{name: 'strawhat',   position: {x: -100, y: 0, z: 0}, offset: {x: 0, y: 10, z: 80}},
			{name: 'tophat',     position: {x:  -50, y: 0, z: 0}, offset: {x: 0, y: 10, z: 80}},
			{name: 'LavaHelmet', position: {x:    0, y: 0, z: 0}, offset: {x: 0, y: 10, z: 80}},
			{name: 'redhat',     position: {x:   50, y: 0, z: 0}, offset: {x: 0, y: 10, z: 80}},
			{name: 'hardhat',    position: {x:  100, y: 0, z: 0}, offset: {x: 0, y: 10, z: 80}}
		],
		modelsPixelsPerMeter: 285.714294,
	};

	var sim;
	var sceneSync;
	var objTemplateByName = {};
	var selectedHat;
	var initialHats = [];
	var loadRequest;

	var altPixelsPerMeter = 165.837418;//current Altspace default
	var scale = 3.5 / CONFIG.modelsPixelsPerMeter * altPixelsPerMeter;

	function main() {
		sim = altspace.utilities.Simulation();
		if (!altspace.inClient) {
			sim.camera.position.z = 400;//inside the enclosure
		}

		var multiloader = altspace.utilities.multiloader;
		multiloader.init({
			crossOrigin: 'anonymous',
			baseUrl: 'models/hats/',
			TRACE: false,//enable for debugging logs
		});
		loadRequest = new multiloader.LoadRequest();
		for (var i=0; i < CONFIG.models.length; i++) {
			var name = CONFIG.models[i].name;
			loadRequest.objUrls.push(name+'.obj');
			loadRequest.mtlUrls.push(name+'.mtl');
		}
		multiloader.load(loadRequest, onLoaded);
	}

	function onLoaded() {
		for (var i=0; i < loadRequest.objects.length; i++) {
			var objTemplate = loadRequest.objects[i];
			var name = CONFIG.models[i].name;//guaranteed to be in same order
			if (!objTemplate) throw Error('Error loading hat model ' + name);
			var v3 = new THREE.Vector3();
			v3.copy(CONFIG.models[i].offset);
			v3.multiplyScalar(1 / CONFIG.modelsPixelsPerMeter * altPixelsPerMeter);

			objTemplate.name = name;
			objTemplate.userData.offset = v3;
			objTemplate.position.copy(CONFIG.models[i].position);//initial position
			objTemplate.scale.set(scale, scale, scale);
			objTemplateByName[name] = objTemplate;//we'll clone in createHat

			//Create one hat (not synced) from template
			var obj = createHat({name: objTemplate.name, sync: false});
			initialHats.push(obj);
		}

		// Now that hat templates ready, init sync.
		var instanceBase = altspace.utilities.sync.getInstance();
		sceneSync = altspace.utilities.behaviors.SceneSync(instanceBase, {
			instantiators: {'Hat': createHat },
			ready: onSyncReady
		});
		sim.scene.addBehavior(sceneSync);
	}

	function onSyncReady() {
		//Attach event handlers to initial hats. Clicking on a hat clones it.
		//Needed to wait until sceneSync ready, since the new hats will be synced.
		for (var i=0; i < initialHats.length; i++) {
			addEventListener(initialHats[i]);
		}
	}

	function addEventListener(obj) {
		obj.addEventListener('cursordown', function(event) {
			if (selectedHat) sceneSync.destroy(selectedHat);
			//destroyOnDisconnect=true so when user leaves, their hat vanishes.
			var myHat = sceneSync.instantiate('Hat', {name: obj.name, sync: true}, true);
			//Add follow behavior here, not in createHat, since only the local hat
			//follows this user (although its position is synced to all users).
			myHat.addBehavior(FollowUserBehavior({scene: sim.scene, ray: event.ray}));
			selectedHat = myHat;
		});
	}

	function createHat(initData){
		var name = initData.name;
		var objTemplate = objTemplateByName[name];
		if (!objTemplate) throw Error('Error creating hat ' + name);
		var obj = objTemplate.clone();
		if (initData.sync) {
			console.log('Creating synced hat ' + name + ' at position', obj.position);
			obj.addBehavior(altspace.utilities.behaviors.Object3DSync({position: true}));
		}
		sim.scene.add(obj);
		return obj;
	}

	function FollowUserBehavior(config){
		config = config || {};
		if (config.scene === undefined) throw Error('config.scene required');
		if (config.ray === undefined) throw Error('config.ray required');
		var object3d;
		var ray;
		var lastRay;
		var offset;

		var interval;
		var autoSendRateMS = 100;

		function awake(o) {
			object3d = o;
			offset = object3d.userData.offset;
			if(!offset) throw Error('Missing offset');
			ray = config.ray;
		  config.scene.addEventListener('cursormove', function(event){
				ray = event.ray;
		  });
		}

		function start() {
			updatePosition();
			startAutoSend();
		}

		function startAutoSend() {
			interval = setInterval(function() {
				var sync = object3d.getBehaviorByType('Object3DSync');
				if (sync) sync.enqueueSend();
			}, autoSendRateMS);
		}

		function update(deltatime) {
			//Ignore slight changes in position.
			var diff = ray.origin.clone().sub(lastRay.origin); 
			if (Math.abs(diff.x) < 1 && 
			    Math.abs(diff.y) < 1 && 
			    Math.abs(diff.z) < 1) return;
			updatePosition();
		}

		function updatePosition() {
			//TODO: Move relative to the user's tracking skeleton, not ray origin.
			var newPosition = ray.origin.clone().add(offset);
			object3d.position.copy(newPosition);
			lastRay = ray;
		}

		function dispose() {
			if (interval) clearInterval(interval);
		}

		return {
			awake: awake,
			start: start,
			update: update,
			dispose: dispose
		};

	}

	return {
		main: main,
	}

}());

HatsApp.main();

</script>
</html>