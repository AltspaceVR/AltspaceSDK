<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Canvas Update Stress Test</title>
		<meta charset="utf-8">
		<!--
		<script src="../../../UnityClient/js/src/dynamic-thrift-buffer.js"></script>
		<script src="../../../UnityClient/js/src/altspace-client.js"></script>
		<script src="../../../UnityClient/js/src/AltRenderer.js"></script>
		<script src="../../../UnityClient/js/src/AltGeoMatSerializer.js"></script>
		<script src="../../../UnityClient/js/src/AltGeoMatSerializer.js"></script>
		-->
		<script src="https://cdn.rawgit.com/mrdoob/three.js/r74/build/three.min.js"></script>
		<script src="https://cdn.rawgit.com/mrdoob/three.js/r74/examples/js/controls/OrbitControls.js"></script>
		<script src="https://cdn.rawgit.com/mrdoob/stats.js/r16/build/stats.min.js"></script>
		<script src="../../dist/altspace.js"></script>
	</head>
	<body>
		<button id="toggle">toggle</button>
		<script>
			var sim = new altspace.utilities.Simulation({auto: false, rendererOptions: {profile: true}}), controls, stats;

			if (!altspace.inClient) {
				controls = new THREE.OrbitControls(sim.camera);
			}

			var numBoxesI = 1;
			var numBoxesJ = 1;
			var boxes = [];
			var textureSize = Math.pow(2, 9);
			console.info('textureSize: ', textureSize, textureSize * textureSize * 4);
			var boxSize = 150;
			var box = new THREE.BoxGeometry(boxSize, boxSize, boxSize * 2);
			function createBox (i, j) {
				var canvas = document.createElement('canvas');
				canvas.width = textureSize;
				canvas.height = textureSize;
				var context = canvas.getContext('2d');
				var texture = new THREE.CanvasTexture(canvas);
				var material = new THREE.MeshBasicMaterial({ map: texture });
				context.fillStyle = 'red';
				context.fillRect(0, 0, textureSize, textureSize);
				texture.needsUpdate = true;

				var mesh = new THREE.Mesh(box, material);
				mesh.position.x = i * boxSize * 1.5 - ((numBoxesI - 1) / 2 * boxSize * 1.5) - 100;
				mesh.position.y = j * boxSize * 1.5 - ((numBoxesJ - 1) / 2 * boxSize * 1.5);
				sim.scene.add(mesh);
				boxes.push({context: context, texture: texture, canvas: canvas});
			}
			
			for (var i = 0; i < numBoxesI; i++) {
				for (var j = 0; j < numBoxesJ; j++) {
					createBox(i, j);
				}
			}

			stats = new Stats();
			stats.showPanel(0);
			stats.domElement.style.zoom = '6';
			document.body.appendChild(stats.domElement);

			var doAnimate = true;
			var i = 0;
			function animate() {
				//requestAnimationFrame(animate);
				if (doAnimate) {
					i += 0.2;
					boxes.forEach(function (box) {
						var w = 256;
						for(var x = 0; x < textureSize/w; x++) {
							for(var y = 0; y < textureSize/w; y++) {
								box.context.fillStyle = 'hsl(' + (Math.random() * 360) + ', 100%, 50%)';
								box.context.fillRect(x * w, y * w, w, w);
							}
						}
						box.texture.needsUpdate = true;

						// box.canvas.toDataURL().length;

						// box.context.getImageData(0, 0, textureSize, textureSize).data.length;

						// var reader = new FileReader();
						// function readBlob () {
						// 	reader.removeEventListener('loadend', readBlob);
						// 	reader.result.byteLength;
						// }
						// reader.addEventListener('loadend', readBlob);
						// box.canvas.toBlob(function (blob) {
						// 	reader.readAsArrayBuffer(blob);
						// });

					});
				}

				if (controls) { 
					controls.update();
				}
				sim.renderer.render(sim.scene, sim.camera);

				stats.update();
			}
			setInterval(animate, 10);
			//animate();

			toggle.addEventListener('click', function () {
				doAnimate = !doAnimate;
			});
		</script>
	</body>
</html>
