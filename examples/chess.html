<!DOCTYPE html>
<html lang='en'>
<head>
<title>Chess</title>
<script src='http://sdk.altvr.com/libs/three.js/r71/build/three.min.js'></script>
<script src='http://sdk.altvr.com/libs/three.js/r71/examples/js/loaders/OBJMTLLoader.js'></script>
<script src='http://sdk.altvr.com/libs/three.js/r71/examples/js/loaders/MTLLoader.js'></script>
<script src='http://sdk.altvr.com/libs/three.js/r71/examples/js/controls/OrbitControls.js'></script>
<script src='http://sdk.altvr.com/libs/altspace.js/latest/altspace.min.js'></script>
<script src='http://cdn.firebase.com/js/client/2.2.9/firebase.js'></script>

<script src='http://sdk.altvr.com/utilities/0.3.2/CursorEffects.js'></script>
<script src='http://sdk.altvr.com/utilities/0.3.2/ColorHoverEffect.js'></script>
<script src='http://sdk.altvr.com/utilities/0.3.2/DragPlaneEffect.js'></script>
<script src='http://sdk.altvr.com/utilities/0.3.2/ThreeBase.js'></script>
<script src='http://sdk.altvr.com/utilities/0.3.2/MultiLoader.js'></script>
<script src='http://sdk.altvr.com/utilities/0.3.2/shims/CursorEvents.js'></script>

</head>
<body>
<script>

ChessApp = (function(){
	//Chess Board with draggable pieces and multiplayer sychronization.
	var scene, camera, renderer;
	var threeBase;
	var inAltspace = window.altspace && window.altspace.inClient;

	function main(){
		//Entry point into the app, kicks off the rendering loop.
		initThreeBase();
		initScene();
		if (inAltspace){
			var enclosureHeight = 1000;//TODO: Get height of enclosure dynamically.
			scene.position.y = enclosureHeight / -2 ;//Lower board onto floor/table.
		}
		ChessBoard.init(scene, threeBase, function(){//onComplete//XXX
			console.log('Chess Board initialized');
			animate();
		});
	}//end main

	function initThreeBase(){
		//ThreeBase synchronizes the game objects across multiple clients.
		var ascp = altspace.utilities.codePen;
		ascp.setName('Chess'); 
		var inCodePen = !!ascp.getPenId().match(/[0-9][a-f].*/);
		var syncParams = inCodePen ? {
			instanceId: ascp.getPenId(),
			authorId: ascp.getAuthorId()
		} : null;
		var syncInstance = altspace.utilities.sync.getInstance(syncParams);
		threeBase = altspace.utilities.ThreeBase;
		threeBase.init(syncInstance);
	}//end initThreeBase

	function initScene(){
		//This app works both in Altspace and in a traditional browser.
		scene = new THREE.Scene();
		if (inAltspace){
		    renderer = altspace.getThreeJSRenderer();
		} else {
			renderer = new THREE.WebGLRenderer({antialias: true});
			camera = new THREE.PerspectiveCamera();
			altspace.utilities.CursorEvents.init(scene, camera);
			altspace.utilities.CursorEvents.initScene(renderer);
			camera.position.z = ChessBoard.BOARD_SIZE;
			camera.position.y = ChessBoard.BOARD_SIZE + 100;
			camera.lookAt(scene.position);
		}
	}//end initScene

	function animate(){
		requestAnimationFrame(animate);
		threeBase.update();
	  renderer.render(scene, camera);
	}//end animate

	return {
		main: main,
	};

}());//end ChessApp

ChessBoard = (function(){
	//Logic for 'responsive' chess board, which sizes itself based on boardSize.
	//Pieces are placed in their initial positions when first loaded, but then
	//can be dragged without restriction (no checking if the move is legal). 
	var scene; 
	var board;
	var whitePieces = [];
	var blackPieces = [];
	var threeBase;

	var CONFIG = Object.freeze({//constants
		boardSize: 700,//chess piece models are scaled to fit the board
		tableHeight: 0,//chess board is raised to be on top of table
		dragPlaneSize: 1000,//boundary for dragging pieces, should be larger than boardSize
		pieces: {
			king: {modelFile: 'king', count: 1},
			queen: {modelFile: 'queen', count: 1},
			bishop: {modelFile: 'bishop', count: 2},
			knight: {modelFile: 'knight', count: 2},
			rook: {modelFile: 'rook', count: 2},
			pawn: {modelFile: 'pawn', count: 8}
		},
		pieceWidth: 16,
		board: {modelFile: 'board', width: 50, height: 1},
		directory: 'https://sdk.altvr.com/examples/models/share/chess',
	});
	var modelScale = CONFIG.boardSize / 8 / CONFIG.pieceWidth;
	var boardScale = CONFIG.boardSize / CONFIG.board.width;

		function init(myScene, myThreeBase, onComplete){
		//Models will take a couple seconds to download, so callback when done.
		if(!myScene || !myThreeBase || !onComplete ||
		  !myScene instanceof THREE.Scene ||
			!myThreeBase  instanceof THREE.Scene ||
			typeof(onComplete) !== 'function'){
			throw new Error('ChessBoard init called with incorrect arguments');
		}
		scene = myScene;
		threeBase = myThreeBase;
		loadModels(function(){//onComplete
			initBoard();
			arrangePieces();
			scene.add(board);
			for(var i=0; i < whitePieces.length; i++){
				var white = whitePieces[i];
				var black = blackPieces[i];
				threeBase.add(white, white.name);
				threeBase.add(black, black.name);
				scene.add(white);
				scene.add(black);
			}
			initEffects();
			onComplete();
		});
	}//end init

	function loadModels(onComplete){
		//Load only 7 different models, then clone and color as necessary. 
		console.log('Downloading chess models...');
		var multiLoader = altspace.utilities.MultiLoader;
		if(!multiLoader){
			throw new Error('MultiLoader module is not available');
		}
		multiLoader.init({
			crossOrigin: 'anonymous',
			baseUrl: CONFIG.directory,
		});
		var req = new multiLoader.LoadRequest();
		var names = Object.keys(CONFIG.pieces);
		for (var i=0; i < names.length; i++){
			var file = CONFIG.pieces[names[i]].modelFile;
			req.objUrls.push(file+'.obj');
			req.mtlUrls.push(file+'.mtl');
		}
		var boardFile = CONFIG.board.modelFile;
		req.objUrls.push(boardFile+'.obj');
		req.mtlUrls.push(boardFile+'.mtl');
		multiLoader.load(req, function(){//onComplete
			if(req.error) {
				throw new Error(req.error);
			}
			for(var i=0; i < req.objects.length; i++) {
				var object = req.objects[i];
				if(i+1 === req.objects.length) {//board is last object
					object.name = 'board';
					board = object;
					continue;
				}
				object.scale.set(modelScale, modelScale, modelScale);
				object.userData.pieceType = names[i];
				object.userData.pieceColor = 'white';
				whitePieces[i] = object;
				var objectClone = object.clone();
				objectClone.userData.pieceColor = 'black';
				blackPieces[i] = objectClone;
				//Set the black color later.
			}
			onComplete();
		});
	}//end loadModels

	function initEffects(){
		var cursorEffects = altspace.utilities.CursorEffects;
		cursorEffects.init(scene);
		//DragPlane should not be bigger than our bounding box, if it is then
		//objects will disappear when they are moved outside of the box.
		var dragPlaneSize = CONFIG.dragPlaneSize;
		var dragPlaneGeo = new THREE.BoxGeometry(dragPlaneSize, 0.25, dragPlaneSize);
		var dragPlaneMat = new THREE.MeshBasicMaterial({
			color: 0xFFFFFF, 
			opacity: 0.25,
			transparent: true,
		});
		dragPlane = new THREE.Mesh(dragPlaneGeo, dragPlaneMat);
		dragPlane.name = 'drag plane';
		var dragEffect = new altspace.utilities.DragPlaneEffect();
		dragEffect.init(dragPlane);
		var redTint = new THREE.Color(0.8, 0.2, 0.2);
		var hoverEffect = new altspace.utilities.ColorHoverEffect();
		hoverEffect.init(redTint);
		for (var i=0; i < whitePieces.length; i++){
			//Add all pieces to our drag-and-drop controls.
			cursorEffects.add(dragEffect, whitePieces[i]);
			cursorEffects.add(dragEffect, blackPieces[i]);
			cursorEffects.add(hoverEffect, whitePieces[i]);
			cursorEffects.add(hoverEffect, blackPieces[i]);
		}
	}//end initEffects

	function initBoard(){
		//Make the board model same size as our boardSize constant.
		board.scale.set(boardScale, boardScale, boardScale);
		board.position.y = CONFIG.tableHeight + (CONFIG.board.height * boardScale / 2); 
		var whiteTint = new THREE.Color(1, 1, 1);
		var blackTint = new THREE.Color(0.2, 0.2, 0.2);
		whitePieces = cloneModels(whitePieces, whiteTint);
		blackPieces = cloneModels(blackPieces, blackTint);
	}//end initBoard

	function cloneModels(pieces, color){
		//Duplicate models so we have a full chess set.
		var newPieces = [];
		var names = Object.keys(CONFIG.pieces);
		for (var i=0; i < names.length; i++){
			for (var j=0; j < CONFIG.pieces[ names[i] ].count; j++){
				pieces[i].userData.pieceNum = j+1;
				var pieceClone = pieces[i].clone();
				var deepColor = function(obj, color){
					if (obj.material){
						//Clone material so only 1 piece will change, not all of that type.
						obj.material = obj.material.clone();
						obj.material.color = color;
					}
					for(var i=0; i< obj.children.length; i++){
						deepColor(obj.children[i], color);
					}
				}
				deepColor(pieceClone, color);
				newPieces.push(pieceClone);
			}
		}
		for (var i=0; i < newPieces.length; i++){
			var object = newPieces[i];
			object.scale.set(modelScale, modelScale, modelScale);
			object.name = //e.g. 'rook-2-white'
				object.userData.pieceType + '-'+
				object.userData.pieceNum + '-' +
				object.userData.pieceColor;
			//Put pieces on top of the board.
			var boardWidth = CONFIG.board.height * boardScale / 2;
			object.position.y += board.position.y + boardWidth;
		}
		return newPieces;

	}//end cloneModels

	function arrangePieces(){
		//Algorithm for determining initial position of pieces.
		var boardSize = CONFIG.boardSize;
		var width = CONFIG.pieceWidth * modelScale;
		var pawnRow = -width + boardSize/2 - width/2;
		var rankRow = boardSize/2 - width/2;
		var offsetX = - boardSize/2 + width/2;
		for (var i=0; i < whitePieces.length; i++){
			var object = whitePieces[i];
			object.position.z = rankRow;
			switch(object.userData.pieceType){
				case 'king':
					object.position.x = (3 * width) + offsetX;
					break;
				case 'queen':
					object.position.x = (4 * width) + offsetX;
					break;
				case 'bishop':
					object.position.x = (2 * width) + offsetX;
					i++;
					object = whitePieces[i];
					object.position.x = (5 * width) + offsetX;
					object.position.z = rankRow;
					break;
				case 'knight':
					object.position.x = (1 * width) + offsetX;
					i++;
					object = whitePieces[i];
					object.position.x = (6 * width) + offsetX;
					object.position.z = rankRow;
					break;
				case 'rook':
					object.position.x = (0 * width) + offsetX;
					i++;
					object = whitePieces[i];
					object.position.x = (7 * width) + offsetX;
					object.position.z = rankRow;
					break;
				case 'pawn':
					for (var j=0; j < 8; j++){
						object = whitePieces[i];
						object.position.x = (j * width) + offsetX;
						object.position.z = pawnRow;
						i++;
					}
					break;
				default:
					console.error('Unexpected piece type', object.userData.pieceType);	
			}
		}
		//Black pieces mirror position of white ones.
		for (var i=0; i < whitePieces.length; i++){
			var white = whitePieces[i];
			var black = blackPieces[i];
			black.position.copy(white.position);
			if (black.userData.pieceType === 'pawn'){
				black.position.z -= boardSize - width * 3;
			} else {
				black.position.z -= boardSize - width;
			}
		}
	}//end arrangePieces

	return {
		BOARD_SIZE: CONFIG.boardSize, 
		init: init,
	};

}());//end ChessBoard


ChessApp.main();

</script>
</body>
</html>
